<!DOCTYPE html>
<html lang="en">


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://kit.fontawesome.com/ef590a2fdb.js" crossorigin="anonymous"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-KK94CHFLLe+nY2dmCWGMq91rCGa5gtU4mk92HdvYe+M/SXH301p5ILy+dN9+nJOZ" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>
    <link rel="stylesheet" href="css/index.css">
    <link rel="stylesheet" href="css/contact.css">
    <link rel="stylesheet" href="css/library.css">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <!-- and it's easy to individually load additional languages -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/java.min.js"></script>
    <link rel="stylesheet" href="css/dracula.css">

    <title>Library</title>

    <style>

        body {
            background-image: url('assets/blurry_background.png');
            background-repeat: no-repeat;
            background-attachment: fixed;
            background-size: cover;
        }

    </style>

    <style>
        .card {
            color: white;
            margin-bottom: 1.5rem;
            background-color: #282a36;
            border-radius: 10px;
        }

        .card-title {
            font-weight: bold;
        }

        .important {
            color: #d63384;
            font-weight: bold;
        }

        ul {
            margin: 0;
            padding-left: 1.2rem;
        }
    </style>

    <style>
        .table-responsive {
            margin: 20px 0;
        }

        h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
            font-weight: bold;
        }

        h3 {
            margin-top: 30px;
            margin-bottom: 15px;
            padding-bottom: 5px;
            font-weight: bold;
        }

        h4 {
            margin-top: 30px;
            margin-bottom: 15px;
            padding-bottom: 5px;
        }

        .content-block {
            background-color: rgba(255, 255, 255, 0.5);
            transition: 0.3s;
            margin-bottom: 25px;
            padding: 15px;
            border-radius: 10px;
        }

        .content-block:hover {
            background-color: rgba(255, 255, 255, 1);
        }

        .code-example {
            background-color: #f8f9fa;
            padding: 5px 15px;
            border-left: 4px solid #0d6efd;
            margin-bottom: 20px;
            border-radius: 4px;
        }

        .comparison-table th {

            color: white;
        }
    </style>

</head>


<body>


<nav class="navbar sticky-top">

    <div class="container-fluid">

        <button class="navbar-toggler" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvasNavbar"
                aria-controls="offcanvasNavbar" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <!--
        <form id="nav-search" class="d-flex mt-3" role="search">
            <input class="form-control me-2" type="search" placeholder="Type something.." aria-label="Search">
            <button class="btn btn-outline-success" type="submit"><strong>Search</strong></button>
        </form>
        -->

        <div class="offcanvas offcanvas-start" tabindex="-1" id="offcanvasNavbar"
             aria-labelledby="offcanvasNavbarLabel">

            <div class="offcanvas-header">
                <h5 class="offcanvas-title" id="offcanvasNavbarLabel"><strong>Menu</strong></h5>
                <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
            </div>

            <div class="offcanvas-body">
                <ul class="navbar-nav justify-content-end flex-grow-1 pe-3">
                    <li class="nav-item">
                        <a class="nav-link" aria-current="page" href="https://moshulika.github.io/library.html"><i
                                class="fa-solid fa-house"></i> <strong>Home</strong></a>
                    </li>

                    <li class="nav-item">
                        <a class="nav-link" href="https://moshulika.github.io/contact"><i class="fa-solid fa-phone"></i>
                            <strong>Contact</strong></a>
                    </li>

                    <li class="nav-item">
                        <a class="nav-link" href="https://moshulika.github.io/skills.html"><i
                                class="fa-solid fa-gears"></i> <strong>Skills</strong></a>
                    </li>

                    <li class="nav-item">
                        <a class="nav-link" href="https://moshulika.github.io/portofoliu.html"><i
                                class="fa-solid fa-book"></i> <strong>Portfolio</strong></a>
                    </li>

                    <li class="nav-item">
                        <a class="nav-link active" href="https://moshulika.github.io/library.html"><i
                                class="fa-solid fa-code"></i> <strong>Library</strong></a>
                    </li>

                </ul>


            </div>

            <div id="offcanvas-logos">

                <a href="http://mc.b-zone.ro/p/discord" target="_blank"><i class="fa-brands fa-discord"></i></a>
                <a href="https://github.com/Moshulika" target="_blank"><i class="fa-brands fa-github"></i></a>
                <a href="mailto:edwardnanescu@gmail.com"><i class="fa-solid fa-envelope"></i></a>


            </div>

        </div>
    </div>
</nav>

<div class="container">

    <div class="row" id="socials-row">

        <div class="col-xs-12 col-lg-6 animate__animated animate__fadeIn" id="picture2">

            <img src="assets/eu.jpg">
            <div id="text">

                <h1>My simple library</h1>
                <h4>..of useful code</h4>

            </div>

        </div>


    </div>


    <br>
    <br>


    <div class="container">

        <div class="row">
            <h1>Chapters</h1>
        </div>

        <div class="library-pills">
            <a href="https://moshulika.github.io/library.html#design" class="library-pill">OOP Design Principles</a>
            <a href="https://moshulika.github.io/library.html#concepts" class="library-pill">OOP Concepts</a>
            <a href="https://moshulika.github.io/library.html#exceptions" class="library-pill">Exceptions</a>
            <a href="multithreading.html#multithreading" class="library-pill">Multithreading</a>
            <a href="multithreading.html#final" class="library-pill">Final Keyword</a>
            <a href="strings.html#strings" class="library-pill">Strings</a>
            <a href="strings.html#regex" class="library-pill">Regex</a>
            <a href="files.html#io" class="library-pill">I/O</a>
            <a href="files.html#files" class="library-pill">Files</a>
            <a href="https://moshulika.github.io/library.html#lambda" class="library-pill">Lambda</a>
            <a href="jdbc.html" class="library-pill">JDBC</a>
            <a href="networking.html#networking" class="library-pill">Networking</a>
            <a href="networking.html#json" class="library-pill">JSON</a>
            <a href="memory.html#memory" class="library-pill">Java Memory</a>
            <a href="structures.html" class="library-pill">Java Data Structures</a>
            <a href="mysql.html" class="library-pill">MySQL</a>
            <a href="c.html" class="library-pill">C/C++</a>
            <a href="junit.html" class="library-pill">Unit Testing</a>
            <a href="linux.html" class="library-pill">Linux</a>
            <a href="git.html" class="library-pill">Git</a>
            <a href="maven.html" class="library-pill">Maven/Gradle</a>
            <a href="rest-api.html" class="library-pill">REST-API</a>
            <a href="python.html" class="library-pill">Python</a>
            <a href="matlab.html" class="library-pill">Matlab</a>
            <a href="assembly.html" class="library-pill">Assembly</a>
            <a href="bits.html" class="library-pill">Java bit manipulation</a>
        </div>

        <div class="row category-title" id="networking">
            <h1>Complete Networking Concepts and Java Socket Programming</h1>
        </div>

        <div class="container">

            <div class="content-block">

                <div class="code-example">

                    <h3>Transmission Control Protocol (TCP)</h3>
                    <p>TCP or Transmission Control Protocol allows secure communication between different applications.
                        TCP is a connection-oriented protocol which means that once a connection is established, data
                        can be transmitted in two directions. This protocol is typically used over the Internet
                        Protocol. Therefore, TCP is also referred to as TCP/IP. TCP has built-in methods to examine for
                        errors and ensure the delivery of data in the order it was sent, making it a complete protocol
                        for transporting information like still images, data files, and web pages.</p>

                </div>

                <div class="code-example">

                    <h3>User Datagram Protocol (UDP)</h3>
                    <p>UDP or User Datagram Protocol is a connection-less protocol that allows data packets to be
                        transmitted between different applications. UDP is a simpler Internet protocol in which
                        error-checking and recovery services are not required. In UDP, there is no overhead for opening
                        a connection, maintaining a connection, or terminating a connection. In UDP, the data is
                        continuously sent to the recipient, whether they receive it or not.</p>
                </div>

                <div class="code-example">
                    <h3>Port Number</h3>
                    <p>A port number is a method to recognize a particular process connecting internet or other network
                        information when it reaches a server. The port number is used to identify different applications
                        uniquely. The port number behaves as a communication endpoint among applications. The port
                        number is correlated with the IP address for transmission and communication among two
                        applications. There are 65,535 port numbers, but not all are used every day.</p>
                </div>

                <div class="code-example">
                    <h3>Protocol</h3>
                    <p>A network protocol is an organized set of commands that define how data is transmitted between
                        different devices in the same network. Network protocols are the reason through which a user can
                        easily communicate with people all over the world and thus play a critical role in modern
                        digital communications. For Example - TCP, FTP, POP, etc.</p>
                </div>

                <div class="code-example">
                    <h3>MAC Address</h3>
                    <p>MAC address stands for Media Access Control address. It is a bizarre identifier that is allocated
                        to a NIC (Network Interface Controller/ Card). It contains a 48 bit or 64-bit address, which is
                        combined with the network adapter. MAC address can be in hexadecimal composition. In simple
                        words, a MAC address is a unique number that is used to track a device in a network.</p>
                </div>

                <div class="code-example">
                    <h3>Socket</h3>
                    <p>A socket is one endpoint of a two-way communication connection between the two applications
                        running on the network. The socket mechanism presents a method of inter-process communication
                        (IPC) by setting named contact points between which the communication occurs. A socket is tied
                        to a port number so that the TCP layer can recognize the application to which the data is
                        intended to be sent.</p>
                </div>

                <div class="code-example">
                    <h3>Connection-oriented and connection-less protocol</h3>
                    <p>In a connection-oriented service, the user must establish a connection before starting the
                        communication. When the connection is established, the user can send the message or the
                        information, and after this, they can release the connection. However, In connectionless
                        protocol, the data is transported in one route from source to destination without verifying that
                        the destination is still there or not or if it is ready to receive the message. Authentication
                        is not needed in the connectionless protocol.</p>
                    <p>Example of Connection-oriented Protocol - Transmission Control Protocol (TCP)</p>
                    <p>Example of Connectionless Protocol - User Datagram Protocol (UDP)</p>
                </div>

            </div>

            <!-- TCP vs IP Table -->
            <div class="content-block">
                <h3>TCP vs IP</h3>
                <div class="table-responsive">
                    <table class="table table-dark table-striped">
                        <thead class="table-dark">
                        <tr>
                            <th>Feature</th>
                            <th>TCP (Transmission Control Protocol)</th>
                            <th>IP (Internet Protocol)</th>
                        </tr>
                        </thead>
                        <tbody>
                        <tr>
                            <td>Purpose</td>
                            <td>Ensures reliable, ordered, and error-checked delivery of data between applications.</td>
                            <td>Provides addressing and routing of packets across networks.</td>
                        </tr>
                        <tr>
                            <td>Type</td>
                            <td>Connection-oriented</td>
                            <td>Connectionless</td>
                        </tr>
                        <tr>
                            <td>Function</td>
                            <td>Manages data transmission between devices, ensuring data integrity and order.</td>
                            <td>Routes packets of data from the source to the destination based on IP addresses.</td>
                        </tr>
                        <tr>
                            <td>Error Handling</td>
                            <td>Yes, includes error checking and recovery mechanisms.</td>
                            <td>No, IP itself does not handle errors; relies on upper-layer protocols like TCP.</td>
                        </tr>
                        <tr>
                            <td>Flow Control</td>
                            <td>Yes, includes flow control mechanisms.</td>
                            <td>No</td>
                        </tr>
                        <tr>
                            <td>Congestion Control</td>
                            <td>Yes, manages network congestion.</td>
                            <td>No</td>
                        </tr>
                        <tr>
                            <td>Data Segmentation</td>
                            <td>Breaks data into smaller packets and reassembles them at the destination.</td>
                            <td>Breaks data into packets but does not handle reassembly.</td>
                        </tr>
                        <tr>
                            <td>Header Size</td>
                            <td>Larger, 20-60 bytes</td>
                            <td>Smaller, typically 20 bytes</td>
                        </tr>
                        <tr>
                            <td>Reliability</td>
                            <td>Provides reliable data transfer</td>
                            <td>Does not guarantee delivery, reliability, or order.</td>
                        </tr>
                        <tr>
                            <td>Transmission Acknowledgment</td>
                            <td>Yes, acknowledges receipt of data packets.</td>
                            <td>No</td>
                        </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- TCP vs UDP Table -->
            <div class="content-block">
                <h3>TCP vs UDP</h3>
                <div class="table-responsive">
                    <table class="table table-dark table-striped">
                        <thead class="table-dark">
                        <tr>
                            <th>Basis</th>
                            <th>Transmission Control Protocol (TCP)</th>
                            <th>User Datagram Protocol (UDP)</th>
                        </tr>
                        </thead>
                        <tbody>
                        <tr>
                            <td>Type of Service</td>
                            <td>TCP is a connection-oriented protocol. Connection orientation means that the
                                communicating devices should establish a connection before transmitting data and should
                                close the connection after transmitting the data.
                            </td>
                            <td>UDP is the Datagram-oriented protocol. This is because there is no overhead for opening
                                a connection, maintaining a connection, or terminating a connection. UDP is efficient
                                for broadcast and multicast types of network transmission.
                            </td>
                        </tr>
                        <tr>
                            <td>Reliability</td>
                            <td>TCP is reliable as it guarantees the delivery of data to the destination router.</td>
                            <td>The delivery of data to the destination cannot be guaranteed in UDP.</td>
                        </tr>
                        <tr>
                            <td>Error checking mechanism</td>
                            <td>TCP provides extensive error-checking mechanisms. It is because it provides flow control
                                and acknowledgment of data.
                            </td>
                            <td>UDP has only the basic error-checking mechanism using checksums.</td>
                        </tr>
                        <tr>
                            <td>Acknowledgment</td>
                            <td>An acknowledgment segment is present.</td>
                            <td>No acknowledgment segment.</td>
                        </tr>
                        <tr>
                            <td>Sequence</td>
                            <td>Sequencing of data is a feature of Transmission Control Protocol (TCP). this means that
                                packets arrive in order at the receiver.
                            </td>
                            <td>There is no sequencing of data in UDP. If the order is required, it has to be managed by
                                the application layer.
                            </td>
                        </tr>
                        <tr>
                            <td>Speed</td>
                            <td>TCP is comparatively slower than UDP.</td>
                            <td>UDP is faster, simpler, and more efficient than TCP.</td>
                        </tr>
                        <tr>
                            <td>Retransmission</td>
                            <td>Retransmission of lost packets is possible in TCP, but not in UDP.</td>
                            <td>There is no retransmission of lost packets in the User Datagram Protocol (UDP).</td>
                        </tr>
                        <tr>
                            <td>Header Length</td>
                            <td>TCP has a (20-60) bytes variable length header.</td>
                            <td>UDP has an 8 bytes fixed-length header.</td>
                        </tr>
                        <tr>
                            <td>Weight</td>
                            <td>TCP is heavy-weight.</td>
                            <td>UDP is lightweight.</td>
                        </tr>
                        <tr>
                            <td>Handshaking Techniques</td>
                            <td>Uses handshakes such as SYN, ACK, SYN-ACK</td>
                            <td>It's a connectionless protocol i.e. No handshake</td>
                        </tr>
                        <tr>
                            <td>Broadcasting</td>
                            <td>TCP doesn't support Broadcasting.</td>
                            <td>UDP supports Broadcasting.</td>
                        </tr>
                        <tr>
                            <td>Protocols</td>
                            <td>TCP is used by HTTP, HTTPS, FTP, SMTP and Telnet.</td>
                            <td>UDP is used by DNS, DHCP, TFTP, SNMP, RIP, and VoIP.</td>
                        </tr>
                        <tr>
                            <td>Stream Type</td>
                            <td>The TCP connection is a byte stream.</td>
                            <td>UDP connection is a message stream.</td>
                        </tr>
                        <tr>
                            <td>Overhead</td>
                            <td>Low but higher than UDP.</td>
                            <td>Very low.</td>
                        </tr>
                        <tr>
                            <td>Applications</td>
                            <td>This protocol is primarily utilized in situations when a safe and trustworthy
                                communication procedure is necessary, such as in email, on the web surfing, and in
                                military services.
                            </td>
                            <td>This protocol is used in situations where quick communication is necessary but where
                                dependability is not a concern, such as VoIP, game streaming, video, and music
                                streaming, etc.
                            </td>
                        </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="content-block">
                <h2>Java Networking Classes</h2>
                <p>The java.net package of the Java programming language includes various classes that provide an
                    easy-to-use means to access network resources. The classes covered in the java.net package are given
                    as follows:</p>

                <div class="code-example">

                    <h4>CacheRequest</h4>
                    <p>The CacheRequest class is used in java whenever there is a need to store resources in
                        ResponseCache. The objects of this class provide an edge for the OutputStream object to store
                        resource data into the cache.</p>
                </div>

                <div class="code-example">
                    <h4>CookieHandler</h4>
                    <p>The CookieHandler class is used in Java to implement a callback mechanism for securing up an HTTP
                        state management policy implementation inside the HTTP protocol handler. The HTTP state
                        management mechanism specifies the mechanism of how to make HTTP requests and responses.</p>
                </div>

                <div class="code-example">
                    <h4>CookieManager</h4>
                    <p>The CookieManager class is used to provide a precise implementation of CookieHandler. This class
                        separates the storage of cookies from the policy surrounding accepting and rejecting cookies. A
                        CookieManager comprises a CookieStore and a CookiePolicy.</p>
                </div>

                <div class="code-example">
                    <h4>DatagramPacket</h4>
                    <p>The DatagramPacket class is used to provide a facility for the connectionless transfer of
                        messages from one system to another. This class provides tools for the production of datagram
                        packets for connectionless transmission by applying the datagram socket class.</p>
                </div>

                <div class="code-example">
                    <h4>InetAddress</h4>
                    <p>The InetAddress class is used to provide methods to get the IP address of any hostname. An IP
                        address is expressed by a 32-bit or 128-bit unsigned number. InetAddress can handle both IPv4
                        and IPv6 addresses.</p>
                </div>

                <div class="code-example">
                    <h4>ServerSocket</h4>
                    <p>The ServerSocket class is used for implementing system-independent implementation of the
                        server-side of a client/server Socket Connection. The constructor for ServerSocket class throws
                        an exception if it can't listen on the specified port. For example - it will throw an exception
                        if the port is already being used.</p>
                </div>
                <div class="code-example">
                    <h4>Socket</h4>
                    <p>The Socket class is used to create socket objects that help the users in implementing all
                        fundamental socket operations. The users can implement various networking actions such as
                        sending, reading data, and closing connections. Each Socket object built using java.net.Socket
                        class has been connected exactly with 1 remote host; for connecting to another host, a user must
                        create a new socket object.</p>
                </div>

                <div class="code-example">
                    <h4>DatagramSocket</h4>
                    <p>The DatagramSocket class is a network socket that provides a connection-less point for sending
                        and receiving packets. Every packet sent from a datagram socket is individually routed and
                        delivered. It can further be practiced for transmitting and accepting broadcast information.
                        Datagram Sockets is Java's mechanism for providing network communication via UDP instead of
                        TCP.</p>
                </div>

                <div class="code-example">
                    <h4>Proxy</h4>
                    <p>A proxy is a changeless object and a kind of tool or method or program or system, which serves to
                        preserve the data of its users and computers. It behaves like a wall between computers and
                        internet users. A Proxy Object represents the Proxy settings to be applied with a
                        connection.</p>
                </div>

                <div class="code-example">
                    <h4>URL</h4>
                    <p>The URL class in Java is the entry point to any available sources on the internet. A Class URL
                        describes a Uniform Resource Locator, which is a signal to a "resource" on the World Wide Web. A
                        source can denote a simple file or directory, or it can indicate a more difficult object, such
                        as a query to a database or a search engine.</p>
                </div>

                <div class="code-example">
                    <h4>URLConnection</h4>
                    <p>The URLConnection class in Java is an abstract class describing a connection of a resource as
                        defined by a similar URL. The URLConnection class is used for assisting two distinct yet
                        interrelated purposes. Firstly it provides control on interaction with a server(especially an
                        HTTP server) than a URL class. Furthermore, with a URLConnection, a user can verify the header
                        transferred by the server and can react consequently. A user can also configure header fields
                        used in client requests using URLConnection.</p>
                </div>


                <h3>Java Networking Interfaces</h3>
                <p>The java.net package of the Java programming language includes various interfaces also that provide
                    an easy-to-use means to access network resources. The interfaces included in the java.net package
                    are as follows:</p>
                <br>

                <div class="code-example">
                    <h4>CookiePolicy</h4>
                    <p>The CookiePolicy interface in the java.net package provides the classes for implementing various
                        networking applications. It decides which cookies should be accepted and which should be
                        rejected. In CookiePolicy, there are three pre-defined policy implementations, namely
                        ACCEPT_ALL, ACCEPT_NONE, and ACCEPT_ORIGINAL_SERVER.</p>
                </div>

            </div>

            <!-- Socket Class Methods Table -->
            <div class="content-block">
                <h3>Socket Class Methods</h3>
                <div class="table-responsive">
                    <table class="table table-dark table-striped">
                        <thead class="table-dark">
                        <tr>
                            <th>S No.</th>
                            <th>Method</th>
                            <th>Description</th>
                        </tr>
                        </thead>
                        <tbody>
                        <tr>
                            <td>1</td>
                            <td>public void connect(SocketAddress host, int timeout)</td>
                            <td>This method is used to connect the socket to the particularized host. This method is
                                required only when the user instantiates the Socket applying the no-argument
                                constructor.
                            </td>
                        </tr>
                        <tr>
                            <td>2</td>
                            <td>public int getPort()</td>
                            <td>This method is used to return the port to which the socket is pinned on the remote
                                machine.
                            </td>
                        </tr>
                        <tr>
                            <td>3</td>
                            <td>public InetAddress getInetAddress()</td>
                            <td>This method is used to return the location of the other computer to which the socket is
                                connected.
                            </td>
                        </tr>
                        <tr>
                            <td>4</td>
                            <td>public int getLocalPort()</td>
                            <td>This method is used to return the port to which the socket is joined on the local
                                machine.
                            </td>
                        </tr>
                        <tr>
                            <td>5</td>
                            <td>public SocketAddress getRemoteSocketAddress()</td>
                            <td>This method returns the location of the remote socket.</td>
                        </tr>
                        <tr>
                            <td>6</td>
                            <td>public InputStream getInputStream()</td>
                            <td>This method is used to return the input stream of the socket. This input stream is
                                combined with the output stream of the remote socket.
                            </td>
                        </tr>
                        <tr>
                            <td>7</td>
                            <td>public OutputStream getOutputStream()</td>
                            <td>This method is used to return the output stream of the socket. The output stream is
                                combined with the input stream of the remote socket.
                            </td>
                        </tr>
                        <tr>
                            <td>8</td>
                            <td>public void close()</td>
                            <td>This method is used to close the socket, which causes the object of the Socket class to
                                no longer be able to connect again to any server.
                            </td>
                        </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- ServerSocket Class Methods Table -->
            <div class="content-block">
                <h3>ServerSocket Class Methods</h3>
                <div class="table-responsive">
                    <table class="table table-dark table-striped">
                        <thead class="table-dark">
                        <tr>
                            <th>S no.</th>
                            <th>Method</th>
                            <th>Description</th>
                        </tr>
                        </thead>
                        <tbody>
                        <tr>
                            <td>1</td>
                            <td>public int getLocalPort()</td>
                            <td>This method is used to return the port that the server socket is monitoring on. This
                                method is beneficial if a user passed 0 as the port number in a constructor and lets the
                                server find a port for him.
                            </td>
                        </tr>
                        <tr>
                            <td>2</td>
                            <td>public void setSoTimeout(int timeout)</td>
                            <td>This method is used to set the time-out value for the time in which the server socket
                                pauses for a client during the accept() method.
                            </td>
                        </tr>
                        <tr>
                            <td>3</td>
                            <td>public Socket accept()</td>
                            <td>This method waits for an incoming client. This method is blocked till either a client
                                combines to the server on the specified port or the socket times out, considering that
                                the time-out value has been set using the setSoTimeout() method. Otherwise, this method
                                will be blocked indefinitely.
                            </td>
                        </tr>
                        <tr>
                            <td>4</td>
                            <td>public void bind(SocketAddress host, int backlog)</td>
                            <td>This method is used to bind the socket to the particularized server and port in the
                                object of SocketAddress. The user should use this method if he has instantiated the
                                ServerSocket using the no-argument constructor.
                            </td>
                        </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="content-block">
                <h2>Socket Programming</h2>
                <p>Java Socket programming is practiced for communication between the applications working on different
                    JRE. Sockets implement the communication tool between two computers using TCP. Java Socket
                    programming can either be connection-oriented or connection-less. In Socket Programming, Socket and
                    ServerSocket classes are managed for connection-oriented socket programming. However, DatagramSocket
                    and DatagramPacket classes are utilized for connection-less socket programming.</p>

                <p>A client application generates a socket on its end of the communication and strives to combine that
                    socket with a server. When the connection is established, the server generates an object of socket
                    class on its communication end. The client and the server can now communicate by writing to and
                    reading from the socket.</p>

                <h3>Steps to establishing a TCP connection between two computing devices using Socket Programming</h3>

                <div class="code-example">

                    <br>
                    <p>The following are the steps that occur on establishing a TCP connection between two computers
                        using socket programming are given as follows:</p>

                    <ul>
                        <li><strong>Step 1</strong> - The server instantiates a ServerSocket object, indicating at which
                            port number communication will occur.
                        </li>
                        <li><strong>Step 2</strong> - After instantiating the ServerSocket object, the server requests
                            the accept() method of the ServerSocket class. This program pauses until a client connects
                            to the server on the given port.
                        </li>
                        <li><strong>Step 3</strong> - After the server is idling, a client instantiates an object of
                            Socket class, defining the server name and the port number to connect to.
                        </li>
                        <li><strong>Step 4</strong> - After the above step, the constructor of the Socket class strives
                            to connect the client to the designated server and the port number. If communication is
                            authenticated, the client forthwith has a Socket object proficient in interacting with the
                            server.
                        </li>
                        <li><strong>Step 5</strong> - On the server-side, the accept() method returns a reference to a
                            new socket on the server connected to the client's socket.
                        </li>
                    </ul>
                    <br>

                </div>

                <br>

                <p>After the connections are stabilized, communication can happen using I/O streams. Each object of a
                    socket class has both an OutputStream and an InputStream. The client's OutputStream is correlated to
                    the server's InputStream, and the client's InputStream is combined with the server's OutputStream.
                    Transmission Control Protocol (TCP) is a two-way communication protocol. Hence information can be
                    transmitted over both streams at the corresponding time.</p>
            </div>

            <!-- Client and Server Code Examples -->
            <div class="content-block">
                <h3>Client Side Example</h3>
                <pre><code class="language-java">import java.io.*;
import java.net.*;

public class clientSide {
    // initialize socket and input output streams
    private Socket socket = null;
    private DataInputStream input = null;
    private DataOutputStream out = null;

    // constructor to put ip address and port
    public clientSide(String address, int port) {
        // establish a connection
        try {
            socket = new Socket(address, port);
            System.out.println("Connected");

            // takes input from terminal
            input = new DataInputStream(System.in);

            // sends output to the socket
            out = new DataOutputStream(socket.getOutputStream());
        }
        catch (UnknownHostException u) {
            System.out.println(u);
        }
        catch (IOException i) {
            System.out.println(i);
        }

        // string to read message from input
        String line = "";

        // keep reading until "End" is input
        while (!line.equals("End")) {
            try {
                line = input.readLine();
                out.writeUTF(line);
            }
            catch (IOException i) {
                System.out.println(i);
            }
        }

        // close the connection
        try {
            input.close();
            out.close();
            socket.close();
        }
        catch (IOException i) {
            System.out.println(i);
        }
    }

    public static void main(String[] args) {
        clientSide client = new clientSide("127.0.0.1", 5000);
    }
}</code></pre>

                <h3>Server Side Example</h3>
                <pre><code class="language-java">import java.io.*;
import java.net.*;

public class serverSide {
    // initialize socket and input stream
    private Socket socket = null;
    private ServerSocket server = null;
    private DataInputStream in = null;

    // constructor with port
    public serverSide(int port) {
        // starts server and waits for a connection
        try {
            server = new ServerSocket(port);
            System.out.println("Server started");
            System.out.println("Waiting for a client ...");

            socket = server.accept();
            System.out.println("Client accepted");

            // takes input from the client socket
            in = new DataInputStream(new BufferedInputStream(socket.getInputStream()));

            String line = "";

            // reads message from client until "End" is sent
            while (!line.equals("End")) {
                try {
                    line = in.readUTF();
                    System.out.println(line);
                }
                catch (IOException i) {
                    System.out.println(i);
                }
            }

            System.out.println("Closing connection");

            // close connection
            socket.close();
            in.close();
        }
        catch (IOException i) {
            System.out.println(i);
        }
    }

    public static void main(String[] args) {
        serverSide server = new serverSide(5000);
    }
}</code></pre>
            </div>

            <div class="content-block">
                <h2>Advantages and Disadvantages</h2>

                <div class="code-example">

                    <h3>Advantages of TCP/IP Model</h3>
                    <ul>
                        <li><strong>Interoperability</strong>: The TCP/IP model allows different types of computers and
                            networks to communicate with each other, promoting compatibility and cooperation among
                            diverse systems.
                        </li>
                        <li><strong>Scalability</strong>: TCP/IP is highly scalable, making it suitable for both small
                            and large networks, from local area networks (LANs) to wide area networks (WANs) like the
                            internet.
                        </li>
                        <li><strong>Standardization</strong>: It is based on open standards and protocols, ensuring that
                            different devices and software can work together without compatibility issues.
                        </li>
                        <li><strong>Flexibility</strong>: The model supports various routing protocols, data types, and
                            communication methods, making it adaptable to different networking needs.
                        </li>
                        <li><strong>Reliability</strong>: TCP/IP includes error-checking and retransmission features
                            that ensure reliable data transfer, even over long distances and through various network
                            conditions.
                        </li>
                    </ul>

                    <h3>Disadvantages of TCP/IP Model</h3>
                    <ul>
                        <li><strong>Complex Configuration</strong>: Setting up and managing a TCP/IP network can be
                            complex, especially for large networks with many devices. This complexity can lead to
                            configuration errors.
                        </li>
                        <li><strong>Security Concerns</strong>: TCP/IP was not originally designed with security in
                            mind. While there are now many security protocols available (such as SSL/TLS), they have
                            been added on top of the basic TCP/IP model, which can lead to vulnerabilities.
                        </li>
                        <li><strong>Inefficiency for Small Networks</strong>: For very small networks, the overhead and
                            complexity of the TCP/IP model may be unnecessary and inefficient compared to simpler
                            networking protocols.
                        </li>
                        <li><strong>Limited by Address Space</strong>: Although IPv6 addresses this issue, the older
                            IPv4 system has a limited address space, which can lead to issues with address exhaustion in
                            larger networks.
                        </li>
                        <li><strong>Data Overhead</strong>: TCP, the transport protocol, includes a significant amount
                            of overhead to ensure reliable transmission. This can reduce efficiency, especially for
                            small data packets or in networks where speed is crucial.
                        </li>
                    </ul>

                </div>

                <div class="code-example">

                    <h3>Advantages of UDP</h3>
                    <ul>
                        <li><strong>Speed</strong>: UDP is faster than TCP because it does not have the overhead of
                            establishing a connection and ensuring reliable data delivery.
                        </li>
                        <li><strong>Lower latency</strong>: Since there is no connection establishment, there is lower
                            latency and faster response time.
                        </li>
                        <li><strong>Simplicity</strong>: UDP has a simpler protocol design than TCP, making it easier to
                            implement and manage.
                        </li>
                        <li><strong>Broadcast support</strong>: UDP supports broadcasting to multiple recipients, making
                            it useful for applications such as video streaming and online gaming.
                        </li>
                        <li><strong>Smaller packet size</strong>: UDP uses smaller packet sizes than TCP, which can
                            reduce network congestion and improve overall network performance.
                        </li>
                        <li>User Datagram Protocol (UDP) is more efficient in terms of both latency and bandwidth.</li>
                    </ul>

                    <h3>Disadvantages of UDP</h3>
                    <ul>
                        <li><strong>No reliability</strong>: UDP does not guarantee delivery of packets or order of
                            delivery, which can lead to missing or duplicate data.
                        </li>
                        <li><strong>No congestion control</strong>: UDP does not have congestion control, which means
                            that it can send packets at a rate that can cause network congestion.
                        </li>
                        <li><strong>Vulnerable to attacks</strong>: UDP is vulnerable to denial-of-service attacks,
                            where an attacker can flood a network with UDP packets, overwhelming the network and causing
                            it to crash.
                        </li>
                        <li><strong>Limited use cases</strong>: UDP is not suitable for applications that require
                            reliable data delivery, such as email or file transfers, and is better suited for
                            applications that can tolerate some data loss, such as video streaming or online gaming.
                        </li>
                    </ul>
                    <br>

                </div>

                <h3>How is UDP used in DDoS attacks?</h3>
                <p>A UDP flood attack is a type of Distributed Denial of Service (DDoS) attack where an attacker sends a
                    large number of User Datagram Protocol (UDP) packets to a target port.</p>

                <p><strong>UDP Protocol</strong>: Unlike TCP, UDP is connectionless and doesn't require a handshake
                    before data transfer. When a UDP packet arrives at a server, it checks the specified port for
                    listening applications. If no app is found, the server sends an ICMP "destination unreachable"
                    packet to the supposed sender (usually a random bystander due to spoofed IP addresses).</p>

                <p><strong>Attack Process</strong>:</p>
                <ol>
                    <li>The attacker sends UDP packets with spoofed IP sender addresses to random ports on the target
                        system.
                    </li>
                    <li>The server checks each incoming packet's port for a listening application (usually not found due
                        to random port selection).
                    </li>
                    <li>The server sends ICMP "destination unreachable" packets to the spoofed sender (random
                        bystanders).
                    </li>
                    <li>The attacker floods the victim with UDP data packets, overwhelming its resources.</li>
                </ol>
            </div>

            <div class="content-block" id="json">
                <h2>HTTP and JSON Examples</h2>

                <h3>HTTP Request Example</h3>
                <pre><code class="language-java">// Step 1: Create a neat value object to hold the URL
URL url = new URL("https://api.nasa.gov/planetary/apod?api_key=DEMO_KEY");

// Step 2: Open a connection on the URL and cast the response
HttpURLConnection connection = (HttpURLConnection) url.openConnection();

// Now it's "open", we can set the request method, headers etc.
connection.setRequestProperty("accept", "application/json");

// This line makes the request
InputStream responseStream = connection.getInputStream();</code></pre>

                <h3>JSON Processing Examples</h3>

                <h4>Reading JSON from URL</h4>
                <pre><code class="language-java">private static String readAll(Reader rd) throws IOException {
    StringBuilder sb = new StringBuilder();
    int cp;
    while ((cp = rd.read()) != -1) {
        sb.append((char) cp);
    }
    return sb.toString();
}

public static JSONObject readJsonFromUrl(String url) throws IOException, JSONException {
    InputStream is = new URL(url).openStream();
    try {
        BufferedReader rd = new BufferedReader(new InputStreamReader(is, Charset.forName("UTF-8")));
        String jsonText = readAll(rd);
        JSONObject json = new JSONObject(jsonText);
        return json;
    } finally {
        is.close();
    }
}

public static void main(String[] args) throws IOException, JSONException {
    JSONObject json = readJsonFromUrl("https://graph.facebook.com/19292868552");
    System.out.println(json.toString());
    System.out.println(json.get("id"));
}</code></pre>

                <h4>Creating and Parsing JSON Objects</h4>
                <pre><code class="language-java">public static void main(String[] args) {
    // Converting JSON data into Java String format
    String k = "{\"Full Name\":\"Ritu Sharma\", \"Tuition Fees\":65400.0, \"Roll No.\":1704310046}";
    Object file = JSONValue.parse(k);

    // In java JSONObject is used to create JSON object
    JSONObject jsonObjectdecode = (JSONObject)file;

    // Converting into Java Data type
    // format From Json is the step of Decoding.
    String name = (String)jsonObjectdecode.get("Full Name");
    double fees = (Double)jsonObjectdecode.get("Tuition Fees");
    long rollno = (Long)jsonObjectdecode.get("Roll No.");
    System.out.println(name + " " + fees + " " + rollno);
}</code></pre>

                <h4>Creating JSON Document</h4>
                <pre><code class="language-java">// Program for print data in JSON format.
public class JavaJsonEncoding {
    public static void main(String args[]) {
        // In java JSONObject is used to create JSON object
        // which is a subclass of java.util.HashMap.
        JSONObject file = new JSONObject();

        file.put("Full Name", "Ritu Sharma");
        file.put("Roll No.", new Integer(1704310046));
        file.put("Tuition Fees", new Double(65400));

        // To print in JSON format.
        System.out.print(file);
    }
}</code></pre>

                <h4>Loading JSON from File</h4>
                <pre><code class="language-java">public static void main(String[] args) throws Exception {
    File f = new File("file.json");
    if (f.exists()){
        InputStream is = new FileInputStream("file.json");
        String jsonTxt = IOUtils.toString(is, "UTF-8");
        System.out.println(jsonTxt);
        JSONObject json = new JSONObject(jsonTxt);
        String a = json.getString("1000");
        System.out.println(a);
    }
}</code></pre>

                <h4>Creating and Writing JSON to File</h4>
                <pre><code class="language-java">public class CreatingJSONDocument {
    public static void main(String[] args) {
        //Creating a JSONObject object
        JSONObject jsonObject = new JSONObject();
        //Inserting key-value pairs into the json object
        jsonObject.put("ID", "1");
        jsonObject.put("First_Name", "Shikhar");
        jsonObject.put("Last_Name", "Dhawan");
        jsonObject.put("Date_Of_Birth", "1981-12-05");
        jsonObject.put("Place_Of_Birth", "Delhi");
        jsonObject.put("Country", "India");
        try {
            FileWriter file = new FileWriter("E:/output.json");
            file.write(jsonObject.toJSONString());
            file.close();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        System.out.println("JSON file created: "+jsonObject);
    }
}</code></pre>
            </div>

            <!-- HTTP Components Table -->
            <div class="content-block">
                <h3>HTTP Components</h3>
                <div class="table-responsive">
                    <table class="table table-dark table-striped">
                        <thead class="table-dark">
                        <tr>
                            <th>HTTP Components</th>
                            <th>Action performed</th>
                        </tr>
                        </thead>
                        <tbody>
                        <tr>
                            <td>HttpClient.Builder</td>
                            <td>A builder of HTTP Clients.</td>
                        </tr>
                        <tr>
                            <td>HttpRequest.BodyPublisher</td>
                            <td>A BodyPublisher converts high-level Java objects into a flow of byte buffers suitable
                                for sending as a request body.
                            </td>
                        </tr>
                        <tr>
                            <td>HttpRequest.Builder</td>
                            <td>A builder of HTTP requests.</td>
                        </tr>
                        <tr>
                            <td>HttpResponse&lt;T&gt;</td>
                            <td>An HTTP response.</td>
                        </tr>
                        <tr>
                            <td>HttpResponse.BodyHandler&lt;T&gt;</td>
                            <td>A handler for response bodies.</td>
                        </tr>
                        <tr>
                            <td>HttpResponse.BodySubscriber&lt;T&gt;</td>
                            <td>A BodySubscriber consumes response body bytes and converts them into a higher-level Java
                                type.
                            </td>
                        </tr>
                        <tr>
                            <td>HttpResponse.PushPromiseHandler&lt;T&gt;</td>
                            <td>A handler for push promises.</td>
                        </tr>
                        <tr>
                            <td>HttpResponse.ResponseInfo</td>
                            <td>Initial response information supplied to a BodyHandler when a response is initially
                                received and before the body is processed.
                            </td>
                        </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>


    </div>


    <footer class="container">

        <hr id="before-footer">
        <div class="row">

            <div class="col footer-text">

                <a href="contact.html">Contact</a>


            </div>

            <div class="col footer-icons">

                <a href="http://mc.b-zone.ro/p/discord" target="_blank"><i class="fa-brands fa-discord"></i></a>
                <a href="https://github.com/Moshulika" target="_blank"><i class="fa-brands fa-github"></i></a>
                <a href="mailto:edwardnanescu@gmail.com"><i class="fa-solid fa-envelope"></i></a>


            </div>

        </div>


    </footer>

</div>

<style>
    /* Scroll to top button styles */
    .scroll-to-top {
        position: fixed;
        bottom: 30px;
        right: 30px;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background-color: #0d6efd;
        color: white;
        border: none;
        cursor: pointer;
        display: none; /* Hidden by default */
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        transition: all 0.3s ease;
        z-index: 1000;
    }

    .scroll-to-top:hover {
        background-color: #0b5ed7;
        transform: translateY(-3px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .scroll-to-top:active {
        transform: translateY(0);
    }

    .scroll-to-top svg {
        width: 24px;
        height: 24px;
        fill: currentColor;
    }

    /* Show the button when user scrolls down */
    .scroll-to-top.visible {
        display: flex;
    }
</style>

<button class="scroll-to-top" aria-label="Scroll to top">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M12 4l-8 8h5v8h6v-8h5z"/>
    </svg>
</button>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-ENjdO4Dr2bkBIFxQpeoTz1HIcje39Wm4jDKdf19U8gI4ddQ3GYNS7NTKfAdVQSZe"
        crossorigin="anonymous"></script>
<script>
    hljs.highlightAll();

</script>
<script>
    // Show/hide scroll to top button based on scroll position
    const scrollToTopButton = document.querySelector('.scroll-to-top');

    window.addEventListener('scroll', () => {
        if (window.pageYOffset > 300) {
            scrollToTopButton.classList.add('visible');
        } else {
            scrollToTopButton.classList.remove('visible');
        }
    });

    // Scroll to top when button is clicked
    scrollToTopButton.addEventListener('click', () => {
        window.scrollTo({
            top: 0,
            behavior: 'smooth'
        });
    });
</script>
<!--
<div class="code-container">

            <div class="code-description"></div>
            <div class="code">

                <pre><code></code></pre>

            </div>

        </div>

        <div class="row">
            <h1>OOP Design principles</h1>
        </div>

        <div class="row">

            <div class="col-12">
                <h1>1. Don't repeat yourself</h1>
            </div>

            <div class="col-xs-12 col-md-6">
                <div class="code">

                <pre><code></code></pre>

                </div>

            </div>

            <div class="col-xs-12 col-md-6">
                <div class="code">

                <pre><code></code></pre>

                </div>

            </div>
        </div>
-->

</body>
</html>